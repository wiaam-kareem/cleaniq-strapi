import Table from 'cli-table3';
import { Command, Option } from 'commander';
import ora from 'ora';
import type { LoadedStrapi } from '@strapi/types';
import * as engineDatatransfer from '../engine';
declare const exitMessageText: (process: string, error?: boolean) => string;
declare const getDefaultExportName: () => string;
type ResultData = engineDatatransfer.ITransferResults<engineDatatransfer.ISourceProvider, engineDatatransfer.IDestinationProvider>['engine'];
declare const buildTransferTable: (resultData: ResultData) => Table.Table | undefined;
declare const DEFAULT_IGNORED_CONTENT_TYPES: string[];
declare const abortTransfer: ({ engine, strapi, }: {
    engine: engineDatatransfer.TransferEngine;
    strapi: LoadedStrapi;
}) => Promise<boolean>;
declare const setSignalHandler: (handler: (...args: unknown[]) => void, signals?: string[]) => Promise<void>;
declare const createStrapiInstance: (opts?: {
    logLevel?: string;
}) => Promise<{
    server: import("@strapi/strapi").Server;
    container: import("@strapi/strapi").Container;
    log: import("winston").Logger;
    fs: import("@strapi/types").StrapiFS;
    eventHub: import("@strapi/strapi").EventHub;
    startupLogger: import("@strapi/types").StartupLogger;
    cron: import("@strapi/strapi").CronService;
    webhookRunner?: import("@strapi/strapi/dist/services/webhook-runner").WebhookRunner | undefined;
    webhookStore?: import("@strapi/strapi").WebhookStore | undefined;
    store?: import("@strapi/strapi").CoreStore | undefined;
    entityValidator?: import("@strapi/strapi").EntityValidator | undefined;
    entityService?: import("@strapi/types/dist/modules/entity-service").EntityService | undefined;
    telemetry: import("@strapi/strapi").TelemetryService;
    requestContext: import("@strapi/strapi").RequestContext;
    customFields: import("@strapi/types/dist/modules/custom-fields").CustomFields;
    fetch: import("@strapi/strapi").Fetch;
    dirs: import("@strapi/strapi").StrapiDirectories;
    admin?: import("@strapi/types/dist/types/core/common").Module | undefined;
    isLoaded: boolean;
    db?: import("@strapi/database").Database | undefined;
    app: any;
    EE?: boolean | undefined;
    components: import("@strapi/types/dist/types/shared").Components;
    reload: import("@strapi/types").Reloader;
    readonly config: any;
    readonly services: any;
    service(uid: import("@strapi/types/dist/types/core/common/uid").Service): any;
    readonly controllers: any;
    controller(uid: import("@strapi/types/dist/types/core/common/uid").Controller): any;
    readonly contentTypes: import("@strapi/types/dist/types/shared").ContentTypes;
    contentType(name: import("@strapi/types/dist/types/core/common/uid").ContentType): any;
    readonly policies: any;
    policy(name: string): any;
    readonly middlewares: any;
    middleware(name: string): any;
    readonly plugins: Record<string, import("@strapi/types/dist/types/core/common").Plugin>;
    plugin(name: string): import("@strapi/types/dist/types/core/common").Plugin;
    readonly hooks: any;
    hook(name: string): any;
    readonly api: Record<string, import("@strapi/types/dist/types/core/common").Module>;
    readonly auth: any;
    readonly contentAPI: any;
    readonly sanitizers: any;
    readonly validators: any;
    start(): Promise<any>;
    destroy(): Promise<void>;
    sendStartupTelemetry(): void;
    openAdmin({ isInitialized }: {
        isInitialized: boolean;
    }): Promise<void>;
    postListen(): Promise<void>;
    listen(): Promise<void>;
    stopWithError(err: unknown, customMessage?: string | undefined): never;
    stop(exitCode?: number | undefined): never;
    loadAdmin(): Promise<void>;
    loadPlugins(): Promise<void>;
    loadPolicies(): Promise<void>;
    loadAPIs(): Promise<void>;
    loadComponents(): Promise<void>;
    loadMiddlewares(): Promise<void>;
    loadApp(): Promise<void>;
    loadSanitizers(): Promise<void>;
    loadValidators(): Promise<void>;
    registerInternalHooks(): void;
    register(): Promise<any>;
    bootstrap(): Promise<any>;
    load(): Promise<any & Required<import("@strapi/types").Strapi>>;
    startWebhooks(): Promise<void>;
    runLifecyclesFunctions(lifecycleName: "destroy" | "register" | "bootstrap"): Promise<void>;
    getModel(uid: import("@strapi/types/dist/types/core/common/uid").ContentType): import("@strapi/types/dist/types/core/schemas").ContentType;
    getModel(uid: `${string}.${string}`): import("@strapi/types/dist/types/core/schemas").Component;
    query(uid: import("@strapi/types/dist/types/core/common/uid").Schema): import("@strapi/database/dist/entity-manager").Repository;
} & Required<import("@strapi/types").Strapi>>;
declare const throttleOption: Option;
declare const excludeOption: Option;
declare const onlyOption: Option;
declare const validateExcludeOnly: (command: Command) => void;
declare const formatDiagnostic: (operation: string) => Parameters<engineDatatransfer.TransferEngine['diagnostics']['onDiagnostic']>[0];
type Loaders = {
    [key in engineDatatransfer.TransferStage]: ora.Ora;
};
type Data = {
    [key in engineDatatransfer.TransferStage]?: {
        startTime?: number;
        endTime?: number;
        bytes?: number;
        count?: number;
    };
};
declare const loadersFactory: (defaultLoaders?: Loaders) => {
    updateLoader: (stage: engineDatatransfer.TransferStage, data: Data) => ora.Ora;
    createLoader: (stage: engineDatatransfer.TransferStage) => ora.Ora;
    getLoader: (stage: engineDatatransfer.TransferStage) => ora.Ora;
};
/**
 * Get the telemetry data to be sent for a didDEITSProcess* event from an initialized transfer engine object
 */
declare const getTransferTelemetryPayload: (engine: engineDatatransfer.TransferEngine) => {
    eventProperties: {
        source: string;
        destination: string;
    };
};
/**
 * Get a transfer engine schema diff handler that confirms with the user before bypassing a schema check
 */
declare const getDiffHandler: (engine: engineDatatransfer.TransferEngine, { force, action, }: {
    force?: boolean | undefined;
    action: string;
}) => (context: engineDatatransfer.SchemaDiffHandlerContext, next: (ctx: engineDatatransfer.SchemaDiffHandlerContext) => void) => Promise<void>;
declare const getAssetsBackupHandler: (engine: engineDatatransfer.TransferEngine, { force, action, }: {
    force?: boolean | undefined;
    action: string;
}) => (context: engineDatatransfer.ErrorHandlerContext, next: (ctx: engineDatatransfer.ErrorHandlerContext) => void) => Promise<void>;
declare const shouldSkipStage: (opts: Partial<engineDatatransfer.ITransferEngineOptions>, dataKind: engineDatatransfer.TransferFilterPreset) => boolean;
declare const parseRestoreFromOptions: (opts: Partial<engineDatatransfer.ITransferEngineOptions>) => import("../strapi/providers/local-destination/strategies/restore").IRestoreOptions;
export { loadersFactory, buildTransferTable, getDefaultExportName, getTransferTelemetryPayload, DEFAULT_IGNORED_CONTENT_TYPES, createStrapiInstance, excludeOption, exitMessageText, onlyOption, throttleOption, validateExcludeOnly, formatDiagnostic, abortTransfer, setSignalHandler, getDiffHandler, getAssetsBackupHandler, shouldSkipStage, parseRestoreFromOptions, };
//# sourceMappingURL=data-transfer.d.ts.map